{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "flow-diagram",
  "type": "registry:component",
  "title": "Flow Diagram",
  "author": "Joe Johnson <01johnson.joe@gmail.com>",
  "description": "A responsive flow diagram component for visualizing processes and workflows",
  "dependencies": [],
  "files": [
    {
      "path": "src/components/flow-diagram.tsx",
      "content": "import clsx from \"clsx\";\nimport React, { memo, useMemo } from \"react\";\nimport { RussianDoll } from \"@/components/ui/russian-doll.tsx\";\n\nconst STYLES = {\n  LINE_WIDTH: 1,\n  CONNECTOR_SIZE: 18,\n  COLUMN_GAP: 32,\n  NODE_PADDING: 16,\n};\n\n/** A node reference: either an ID string, or an object with overrides */\nexport type FlowNodeId = string;\nexport type FlowNodeRef =\n  | FlowNodeId\n  | {\n      /** stable identifier */\n      id: FlowNodeId;\n      /** display title (defaults to id) */\n      title?: string;\n      /** optional custom React element to render inside this node */\n      element?: React.ReactNode;\n    };\n/** An item in a column: either a node or a nested fork (columns definition) */\nexport type FlowColumnItem = FlowNodeRef | FlowColumnsDefinition;\nexport type FlowColumn = FlowColumnItem[];\n/** A fork is an array of columns */\nexport type FlowColumnsDefinition = FlowColumn[];\n/** The overall graph: a sequence of nodeRefs or a main columns definition */\nexport type FlowGraphDefinition = FlowColumnItem[];\n\n/** Top-level prop for Flow */\nexport interface Nodes {\n  graph: FlowGraphDefinition;\n}\n\ntype ParsedGraphResult = {\n  initialNodeRefs: FlowNodeRef[];\n  mainColumnsDefinition: FlowColumnsDefinition | null;\n  rejoinNodeRefs: FlowNodeRef[];\n  hasRejoinNodes: boolean;\n};\n\nconst getColumnContainerClasses = (): string => {\n  return \"flex flex-row justify-center gap-x-[var(--column-gap)] bg-background relative  h-full\";\n};\n\nconst getNodePaddingClasses = (\n  _isFirst: boolean,\n  hasBottomPadding: boolean\n): string => {\n  const paddingTopClass = `pt-[var(--node-padding)]`;\n  const paddingBottomClass = hasBottomPadding ? `pb-[var(--node-padding)]` : \"\";\n  return `${paddingTopClass} ${paddingBottomClass} relative`.trim();\n};\n\nconst BASE_BORDER_STYLES: React.CSSProperties = {\n  borderTopWidth: \"var(--line-width)\",\n  borderTopStyle: \"solid\",\n  borderTopColor: \"var(--border)\",\n};\nconst FULL_BORDER_STYLES: React.CSSProperties = {\n  ...BASE_BORDER_STYLES,\n  borderBottomWidth: \"var(--line-width)\",\n  borderBottomStyle: \"solid\",\n  borderBottomColor: \"var(--border)\",\n};\ntype LineProps = React.HTMLAttributes<HTMLDivElement>;\nconst Line = memo(function Line({ className, ...rest }: LineProps) {\n  return <div className={clsx(\"bg-border\", className)} {...rest} />;\n});\n\ntype ConnectorProps = {\n  side?: \"left\" | \"right\";\n  hasNextSibling?: boolean;\n};\nconst Connector = memo(function Connector({\n  side,\n  hasNextSibling = false,\n}: ConnectorProps) {\n  if (side === \"left\" || side === \"right\") {\n    const isLeft = side === \"left\";\n    const coverStyles: React.CSSProperties = {\n      top: \"calc(-1 * var(--line-width))\",\n      bottom: \"calc(-1 * var(--line-width))\",\n      [isLeft ? \"left\" : \"right\"]: 0,\n      [isLeft ? \"right\" : \"left\"]: \"calc(50% - var(--corner-offset))\",\n    };\n    const cornerOffset = \"calc(50% - var(--corner-offset))\";\n    const lineOffset = \"calc(-1 * var(--line-width))\";\n    const topCornerClass = clsx(\n      \"absolute border-t border-[var(--border)]\",\n      isLeft ? \"border-l rounded-tl-md\" : \"border-r rounded-tr-md\"\n    );\n    const topCornerStyle: React.CSSProperties = {\n      width: \"var(--connector-size)\",\n      height: \"var(--connector-size)\",\n      [isLeft ? \"borderLeftWidth\" : \"borderRightWidth\"]: \"var(--line-width)\",\n      borderTopWidth: \"var(--line-width)\",\n      [isLeft ? \"right\" : \"left\"]: cornerOffset,\n      top: lineOffset,\n    };\n    const bottomCornerClass = clsx(\n      \"absolute border-b border-[var(--border)]\",\n      isLeft ? \"border-l rounded-bl-md\" : \"border-r rounded-br-md\"\n    );\n    const bottomCornerStyle: React.CSSProperties = {\n      width: \"var(--connector-size)\",\n      height: \"var(--connector-size)\",\n      [isLeft ? \"borderLeftWidth\" : \"borderRightWidth\"]: \"var(--line-width)\",\n      borderBottomWidth: \"var(--line-width)\",\n      [isLeft ? \"right\" : \"left\"]: cornerOffset,\n      bottom: lineOffset,\n    };\n    return (\n      <>\n        <div className=\"absolute bg-background\" style={coverStyles} />\n        <div className={topCornerClass} style={topCornerStyle} />\n        {hasNextSibling && (\n          <div className={bottomCornerClass} style={bottomCornerStyle} />\n        )}\n      </>\n    );\n  }\n  return (\n    <Line className=\"absolute left-1/2 -translate-x-1/2 top-0 h-[var(--connector-size)] w-[var(--line-width)]\" />\n  );\n});\n\nfunction shouldDrawBranchConnector(\n  _item: FlowNodeId,\n  column: FlowColumn,\n  itemIndex: number,\n  colIndex: number,\n  totalColumns: number,\n  hasNextSibling: boolean\n): boolean {\n  if (!hasNextSibling) {\n    return false;\n  }\n\n  const isLastNodeInBranch = itemIndex === column.length - 1;\n  const isLastColumn = colIndex === totalColumns - 1;\n\n  if (isLastNodeInBranch && !isLastColumn) {\n    return true;\n  }\n\n  return false;\n}\n\nconst ColumnComponent = memo(function ColumnComponent({\n  column,\n  colIndex,\n  totalColumns,\n  baseKey,\n  hasNextSibling,\n}: {\n  column: FlowColumn;\n  colIndex: number;\n  totalColumns: number;\n  baseKey: string;\n  hasNextSibling: boolean;\n}) {\n  const isFirstColumn = colIndex === 0;\n  const isLastColumn = colIndex === totalColumns - 1;\n  const isMiddleColumn = !isFirstColumn && !isLastColumn;\n\n  return (\n    <div\n      key={`${baseKey}-col-${colIndex}`}\n      className=\"flex flex-col items-center bg-background relative pb-[var(--node-padding)]\"\n    >\n      {isFirstColumn && (\n        <Connector side=\"left\" hasNextSibling={hasNextSibling} />\n      )}\n      {isLastColumn && (\n        <Connector side=\"right\" hasNextSibling={hasNextSibling} />\n      )}\n      {isMiddleColumn && <Connector />}\n      {column.map((item, itemIndex) => {\n        const itemKey = `${baseKey}-col-${colIndex}-item-${itemIndex}`;\n        const hasContinuation = itemIndex < column.length - 1;\n        const isConverging = itemIndex === column.length - 1 && hasNextSibling;\n        // Node reference (string or object)\n        if (!Array.isArray(item)) {\n          const { id, title, element } = normalizeNodeRef(item as FlowNodeRef);\n          const needsConnectorAbove =\n            itemIndex > 0 && Array.isArray(column[itemIndex - 1]);\n          return (\n            <React.Fragment key={itemKey}>\n              <div\n                className={clsx(\n                  getNodePaddingClasses(itemIndex === 0, hasContinuation),\n                  isConverging && \"flex-1 flex flex-col items-center\"\n                )}\n              >\n                {needsConnectorAbove && (\n                  <Line className=\"absolute top-0 left-1/2 -translate-x-1/2 h-[var(--node-padding)] w-[var(--line-width)]\" />\n                )}\n                <div className=\"z-1\">\n                  <RussianDoll title={title}>{element}</RussianDoll>\n                </div>\n                {shouldDrawBranchConnector(\n                  id,\n                  column,\n                  itemIndex,\n                  colIndex,\n                  totalColumns,\n                  hasNextSibling\n                ) && (\n                  <Line className=\"absolute bottom-0 left-1/2 -translate-x-1/2 h-[calc(var(--node-padding))] w-[var(--line-width)]\" />\n                )}\n                {hasContinuation && (\n                  <Line className=\"absolute bottom-[calc(-1*var(--node-padding))] left-1/2 -translate-x-1/2 h-[calc(2*var(--node-padding))] w-[var(--line-width)]\" />\n                )}\n                {isConverging && (\n                  <Line className=\"flex-1 w-[var(--line-width)]\" />\n                )}\n                {isConverging && !isFirstColumn && !isLastColumn && (\n                  <Line className=\"absolute bottom-[calc(-1*var(--node-padding))] left-1/2 -translate-x-1/2 h-[var(--node-padding)] w-[var(--line-width)]\" />\n                )}\n              </div>\n            </React.Fragment>\n          );\n        }\n        // Nested fork\n        const nested = item as FlowColumnsDefinition;\n        const hasNext = itemIndex < column.length - 1;\n        const willConverge = hasNextSibling && itemIndex === column.length - 1;\n        return (\n          <NestedColumns\n            key={itemKey}\n            columns={nested}\n            baseKey={itemKey}\n            hasNextSibling={hasNext || willConverge}\n          />\n        );\n      })}\n    </div>\n  );\n});\n\nconst NestedColumns = memo(function NestedColumns({\n  columns,\n  baseKey,\n  hasNextSibling,\n}: {\n  columns: FlowColumnsDefinition;\n  baseKey: string;\n  hasNextSibling: boolean;\n}) {\n  const borderStyles: React.CSSProperties = hasNextSibling\n    ? FULL_BORDER_STYLES\n    : BASE_BORDER_STYLES;\n\n  return (\n    <div\n      key={`${baseKey}-cols-container`}\n      className={getColumnContainerClasses()}\n      style={borderStyles}\n    >\n      {columns.map((column, colIndex) => (\n        <ColumnComponent\n          key={`${baseKey}-col-${colIndex}`}\n          column={column}\n          colIndex={colIndex}\n          totalColumns={columns.length}\n          baseKey={baseKey}\n          hasNextSibling={hasNextSibling}\n        />\n      ))}\n    </div>\n  );\n});\n\n/**\n * Normalize a FlowNodeRef into { id, title, element }\n */\nfunction normalizeNodeRef(ref: FlowNodeRef): {\n  id: string;\n  title: string;\n  element?: React.ReactNode;\n} {\n  if (typeof ref === \"string\") {\n    return { id: ref, title: ref };\n  }\n  return { id: ref.id, title: ref.title ?? ref.id, element: ref.element };\n}\n\nfunction parseGraphDefinition(graph: FlowGraphDefinition): ParsedGraphResult {\n  const initialNodeRefs: FlowNodeRef[] = [];\n  let mainColumnsDefinition: FlowColumnsDefinition | null = null;\n  const rejoinNodeRefs: FlowNodeRef[] = [];\n\n  for (const item of graph) {\n    // node reference (string or object)\n    if (\n      typeof item === \"string\" ||\n      (typeof item === \"object\" && !Array.isArray(item) && \"id\" in item)\n    ) {\n      if (mainColumnsDefinition) {\n        rejoinNodeRefs.push(item as FlowNodeRef);\n      } else {\n        initialNodeRefs.push(item as FlowNodeRef);\n      }\n      // main fork definition\n    } else if (Array.isArray(item) && !mainColumnsDefinition) {\n      const isPotentialColumnsDefinition = item.every(Array.isArray);\n      if (isPotentialColumnsDefinition) {\n        mainColumnsDefinition = item as FlowColumnsDefinition;\n      } else {\n        throw new Error(\n          `Invalid main structure: Expected an array of columns (Array<Array<...>>). Found: ${JSON.stringify(\n            item\n          )}`\n        );\n      }\n    } else if (mainColumnsDefinition) {\n      throw new Error(\n        `Multiple main column definitions found or invalid item after definition. Found: ${JSON.stringify(\n          item\n        )}`\n      );\n    } else {\n      throw new Error(\n        `Invalid item in main graph definition: ${JSON.stringify(item)}`\n      );\n    }\n  }\n\n  return {\n    initialNodeRefs,\n    mainColumnsDefinition,\n    rejoinNodeRefs,\n    hasRejoinNodes: rejoinNodeRefs.length > 0,\n  };\n}\n\nexport const FlowDiagram = memo(function FlowDiagram({\n  nodes,\n}: {\n  nodes: Nodes;\n}) {\n  const {\n    initialNodeRefs,\n    mainColumnsDefinition,\n    rejoinNodeRefs,\n    hasRejoinNodes,\n  } = useMemo(() => parseGraphDefinition(nodes.graph), [nodes.graph]);\n\n  const cornerOffset = `${STYLES.CONNECTOR_SIZE - STYLES.LINE_WIDTH / 2}px`;\n\n  const flowStyleVariables = {\n    \"--line-width\": `${STYLES.LINE_WIDTH}px`,\n    \"--connector-size\": `${STYLES.CONNECTOR_SIZE}px`,\n    \"--corner-offset\": cornerOffset,\n    \"--column-gap\": `${STYLES.COLUMN_GAP}px`,\n    \"--node-padding\": `${STYLES.NODE_PADDING}px`,\n    \"--border-color\": \"hsl(var(--border))\",\n  } as React.CSSProperties;\n\n  const initialNodes = initialNodeRefs.map((ref) => {\n    const { id, title, element } = normalizeNodeRef(ref);\n    return (\n      <RussianDoll\n        key={id}\n        title={title}\n        className={clsx(\"py-[var(--node-padding)]\")}\n      >\n        {element}\n      </RussianDoll>\n    );\n  });\n  const rejoinNodes = rejoinNodeRefs.map((ref) => {\n    const { id, title, element } = normalizeNodeRef(ref);\n    return (\n      <RussianDoll\n        key={id}\n        title={title}\n        className={clsx(\"py-[var(--node-padding)]\")}\n      >\n        {element}\n      </RussianDoll>\n    );\n  });\n\n  return (\n    <div\n      className=\"flex flex-col items-center relative bg-background\"\n      style={flowStyleVariables}\n    >\n      <Line className=\"absolute top-5 bottom-5 left-1/2 transform -translate-x-1/2 w-[var(--line-width)]\" />\n      {initialNodes}\n      {mainColumnsDefinition && (\n        <NestedColumns\n          columns={mainColumnsDefinition}\n          baseKey=\"main\"\n          hasNextSibling={hasRejoinNodes}\n        />\n      )}\n      {rejoinNodes}\n    </div>\n  );\n});\n",
      "type": "registry:component"
    }
  ],
  "docs": "www.compjoenents.com/r/flow-diagram",
  "categories": [
    "charts",
    "diagrams"
  ]
}